== Next

Read properties



Improvements:
* The current interpretation is "process source to output (from where it is
  installed) and copy to org". Better: "process source to (a) and copy to (b)
  (from where it is installed)" - better outdated checks. (a) should be called
  "output".
* Built should include skipped and (successfully built) (need a name for that)

Skipping:
* We do not want to rebuild a skipped entry if the source has not changed.
  However, we need to build an entry that is not yet built. Both "skipped" and
  "not built" have no existing output file. In order to distinguish between
  these two states, a "skipped" property is required.
* The "skipped" property could be stored in a status file or as tag files.  In
* order to determine when to rebuild a skipped entry, a timestamp is required
  for skipped files as well as for built entries.
* If the skipped property is not present, it is treated as false.
* If skipped is false and the output does not exist, the entry is treated as
  not yet built and is rebuilt.
* If skipped is true, but the output exists, the entry is inconsistent and is
  rebuilt.
* After building, the skipped property is updated.
* The skipped flag (also the built status) is only meaningful if the entry is
  current.

Open questions:
* if we store the timestamp for skipped entries in a status file, do we want to
  use it for built entries as well, or do we use the timestamp of the org file
  in this case?
  We need to consider the timestamps of the source and output files in any
  case.
* do we want to use a status file or tag files for the skipped flag?
* When do we uninstall a newly skipped entry? Note that it can't be
  automatically reinstalled if it's newly non-skipped without tracking the
  install status.

Answers:
* use the timestamp of the file
* uninstalling is done immediately; for reinstalling, the user has to perform
  "install" again

On directory names:
* the names output/org are bad
* install and build are already used for the operations


With skipped property:
built? |skipped? |meaning                  |build condition
-------+---------+-------------------------+------------
false  |false    |not built/output missing |always
false  |true     |regular skipped          |source newer than timestamp
true   |false    |regular built            |source newer than org (or timestamp)
true   |true     |inconsistent             |always

Built: output AND org must exist (?)

Alternatives:
* Build into org only, copy to output only on "update"; also, uninstall a
  skipped entry only on update
* Recognize missing output files (as opposed to not built) by using a
  built/built/skipped status
* Store an installed flag, so we can selectively install files ("manual skip"),
  "update" (process only the installed files) and automatically
  uninstall/reinstall on skipped status change.


== Status file

On startup, Coffle constructs the entries with their respective properties from
the status file. at_exit, Coffle collects the properties and writes the status file.

Status file: YAML. Structure:
* version
* entries=>
** entry path=>
*** {property=>value)}
* ...



== High priority

* Uninstalling directories:
  * Need hierarchical entries structure?
  * Simple approach: remove directory if empty after children uninstalled
  * Better: remove directory if empty and was created by coffle?
* The preconditions in the specific entries should be checked in the entries,
  or better yet (?), the methods just called and throw an exception/return a
  result if they cannot do that
* "full" test for backups
* "full" test: install into symlink directory
* Should backup filenames really be unescaped?
  => advantage: simple to restore without coffle
  => disadvantage: no housekeeping files possible
     => not necessary with coffle files?
	    => unescape everwhere?
* Should there be a single .coffle directory in source?
  => probably yes, so we can freely add things later
  => where would things like host class definitions go? need further structure?
  => how are coffle source directories marked?
* Need a directory specification version, so we can add migrations
  => don't resort to "no spec => version 0" so we can recognize a missing spec
* What happens if a entry is no longer present? how to detect?
  => should be restored
  => ?
* Remove hack @included_messages - why is the file read twice (require should
  only read it once)?
* Uninstall in reverse direction unless we have hierarchic entries






== Low priority

Unit tests:
* Use TestEntry whereever useful (especially in entry_test)
* test Pathname.touch!
* test the TestHelper methods

Other:
* Make it possible to use coffle commands from the output directory (and
  subdirectories), using the actual (unescaped) filenames (allow completion)
* Whether a target is considered removed or replaced should not be depend on
  the existence of the backup, but instead on whether it was installed (keep a
  list)
  * then we can distinguish removed (no backup) from not installed on uninstall
  * either in a status file or in flag files
* Special files, like ssh authorized keys: define keys, then invoke keys in
  host blocks:
  {{{
  <% ssh_define_keys do %>
    ssh-dss AAAAB3N...DjB/A martin@magrathea
    ssh-dss AAAAB3N...Y2KjL martin@damogran
  <% end %>

  <% host "sedna" do %>
    <%= ssh_keys "martin@magrathea", "martin@damogran" %>
  <% end %>
  }}}
* colored messages (rainbow gem) (?) (no gem requirements!)
* distinguish preprocessor by file extension
  * additional file name escaping required
  * Pro: different pp possible
  * Con: collision possible
  * Allow unprocessed files.
    * special case of different preprocessor (pro/con see there)
    * symlink directly (target->source instead of ->output)?
      * Pro: changes to file possible
      * Con: 
* Conditionals: host classes, user names
* Specify individual files on the command line
  * Update automessage command to rebuild only this file
* Message if file is not installed on build
* command clean, which cleans source/.output etc.
  * only if nothing is installed, override with --force
  * print a warning that the symlinks are now broken
* facilitate ignoring autogenerated files for revision control
  * move all coffle directories (.output, .install) to coffle?
* coffle init
* coffle import
* allow help message/coffle init even in non-source-directory
* add .coffle_target/ to the target, so we can do coffle commands from there
* better solution for installing a removed or replaced target:
  * switches to drop the old back or the target
  * operation drop_backup
* similarly, allow uninstalling of removed or replaced target with a switch
* Handle error condition: backup directory is blocked by a file
* Handle error condition: when a directory was refused, all other entries in
  this directory must also be skipped (if the target directory for a file entry
  does not exist, we can probably assume that it was refused and skip its
  contents)
* tell the user what he did wrong and what to do on refuse
* allow "file should not exist" option (like skipping)
* allow "symlink to ..." (like skipping)
* Should we remove directory entries and just (try to) create the containing
  directory for file entries?
  * simplifies backup, validity rules etc.
  * means we cannot have empty directores
  * makes it more difficult to properly skip files whose path is blocked by
    another directory
* The operations should return a result object, with
  * a message
  * a performed flag
  * a success flag



