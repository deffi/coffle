== Next

Entries can have properties. On startup, Coffle constructs the entries with
their respective properties from the status file. at_exit, Coffle collects the
properties and writes the status file.

Status file:
* YAML format (it's in the standard library).
* Contains version

Structure: TODO
* version
* entries
** entry path...
*** property...
* ...

Skipping:
* a missing output file is not treated as "skipped"
  => need a "skipped" property which is only set when skipped (and reset when
     built)
* need to determine when to rebuild a skipped file
  => need a timestamp property for skipped files
* skipped property not present: equivalent to false
* what if skipped=true, but the output exists?
  => treat as not current (needs rebuild)
  => skipped flag is only meaningful if current
  => make sure the state is written correctly
  => NB: if the output exist, it may also be installed

Open questions:
* generated file: use timestamp of output/org file or from status file?
  => output file: "backwards compatible", touchable, works without status file
  => status file: simpler current checks
  => probably output file: undefined if skipped and output exists
* Do we want to distinguish "not built" from "output missing"? If yes:
  * skipped property not present means "not built", false means "built"
  * better: output_state: nil/built/missing
  * probably not, much more complicated and not much better

With skipped property:
output |skipped? |meaning                  |build condition
-------+---------+-------------------------+------------
false  |false    |not built/output missing |always
false  |true     |regular skipped          |source newer than timestamp
true   |false    |regular built            |source newer than org (or timestamp)
true   |true     |inconsistent             |always

Built: output AND org must exist (?)



== High priority

* Uninstalling directories:
  * Need hierarchical entries structure?
  * Simple approach: remove directory if empty after children uninstalled
  * Better: remove directory if empty and was created by coffle?
* The preconditions in the specific entries should be checked in the entries,
  or better yet (?), the methods just called and throw an exception/return a
  result if they cannot do that
* "full" test for backups
* "full" test: install into symlink directory
* Should backup filenames really be unescaped?
  => advantage: simple to restore without coffle
  => disadvantage: no housekeeping files possible
     => not necessary with coffle files?
	    => unescape everwhere?
* Should there be a single .coffle directory in source?
  => probably yes, so we can freely add things later
  => where would things like host class definitions go? need further structure?
  => how are coffle source directories marked?
* Need a directory specification version, so we can add migrations
  => don't resort to "no spec => version 0" so we can recognize a missing spec
* What happens if a entry is no longer present? how to detect?
  => should be restored
  => ?
* Remove hack @included_messages - why is the file read twice (require should
  only read it once)?
* Uninstall in reverse direction unless we have hierarchic entries






== Low priority

Unit tests:
* Use TestEntry whereever useful (especially in entry_test)
* test Pathname.touch!
* test the TestHelper methods

Other:
* Make it possible to use coffle commands from the output directory (and
  subdirectories), using the actual (unescaped) filenames (allow completion)
* Whether a target is considered removed or replaced should not be depend on
  the existence of the backup, but instead on whether it was installed (keep a
  list)
  * then we can distinguish removed (no backup) from not installed on uninstall
  * either in a status file or in flag files
* Special files, like ssh authorized keys: define keys, then invoke keys in
  host blocks:
  {{{
  <% ssh_define_keys do %>
    ssh-dss AAAAB3N...DjB/A martin@magrathea
    ssh-dss AAAAB3N...Y2KjL martin@damogran
  <% end %>

  <% host "sedna" do %>
    <%= ssh_keys "martin@magrathea", "martin@damogran" %>
  <% end %>
  }}}
* colored messages (rainbow gem) (?) (no gem requirements!)
* distinguish preprocessor by file extension
  * additional file name escaping required
  * Pro: different pp possible
  * Con: collision possible
  * Allow unprocessed files.
    * special case of different preprocessor (pro/con see there)
    * symlink directly (target->source instead of ->output)?
      * Pro: changes to file possible
      * Con: 
* Conditionals: host classes, user names
* Specify individual files on the command line
  * Update automessage command to rebuild only this file
* Message if file is not installed on build
* command clean, which cleans source/.output etc.
  * only if nothing is installed, override with --force
  * print a warning that the symlinks are now broken
* facilitate ignoring autogenerated files for revision control
  * move all coffle directories (.output, .install) to coffle?
* coffle init
* coffle import
* allow help message/coffle init even in non-source-directory
* add .coffle_target/ to the target, so we can do coffle commands from there
* better solution for installing a removed or replaced target:
  * switches to drop the old back or the target
  * operation drop_backup
* similarly, allow uninstalling of removed or replaced target with a switch
* Handle error condition: backup directory is blocked by a file
* Handle error condition: when a directory was refused, all other entries in
  this directory must also be skipped (if the target directory for a file entry
  does not exist, we can probably assume that it was refused and skip its
  contents)
* tell the user what he did wrong and what to do on refuse
* allow "file should not exist" option (like skipping)
* allow "symlink to ..." (like skipping)
* Should we remove directory entries and just (try to) create the containing
  directory for file entries?
  * simplifies backup, validity rules etc.
  * means we cannot have empty directores
  * makes it more difficult to properly skip files whose path is blocked by
    another directory
* The operations should return a result object, with
  * a message
  * a performed flag
  * a success flag



