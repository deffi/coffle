== Next

Built: output AND org must exist (?), and make test that catches the current
implementation

Improvements:
* The current interpretation is "process source to output (from where it is
  installed) and copy to org". Better: "process source to (a) and copy to (b)
  (from where it is installed)" - better outdated checks. (a) should be called
  "output".
* Built should include skipped and (successfully built) (need a name for that)

On directory names:
* the names output/org are bad
* install and build are already used for the operations


With skipped property:
built? |skipped? |meaning                  |build condition
-------+---------+-------------------------+------------
false  |false    |not built/output missing |always
false  |true     |regular skipped          |source newer than timestamp
true   |false    |regular built            |source newer than org (or timestamp)
true   |true     |inconsistent             |always

Alternatives:
* Build into org only, copy to output only on "update"; also, uninstall a
  skipped entry only on update
* Recognize missing output files (as opposed to not built) by using a
  built/built/skipped status
* Store an installed flag, so we can selectively install files ("manual skip"),
  "update" (process only the installed files) and automatically
  uninstall/reinstall on skipped status change.


== Status file

On startup, Coffle constructs the entries with their respective properties from
the status file. at_exit, Coffle collects the properties and writes the status file.

Status file: YAML. Structure:
* version
* entries=>
** entry path=>
*** {property=>value)}
* ...



== High priority

* Uninstalling directories:
  * Need hierarchical entries structure?
  * Simple approach: remove directory if empty after children uninstalled
  * Better: remove directory if empty and was created by coffle?
* The preconditions in the specific entries should be checked in the entries,
  or better yet (?), the methods just called and throw an exception/return a
  result if they cannot do that
* "full" test for backups
* "full" test: install into symlink directory
* Should backup filenames really be unescaped?
  => advantage: simple to restore without coffle
  => disadvantage: no housekeeping files possible
     => not necessary with coffle files?
	    => unescape everwhere?
* Should there be a single .coffle directory in source?
  => probably yes, so we can freely add things later
  => where would things like host class definitions go? need further structure?
  => how are coffle source directories marked?
* Need a directory specification version, so we can add migrations
  => don't resort to "no spec => version 0" so we can recognize a missing spec
* What happens if a entry is no longer present? how to detect?
  => should be restored
  => ?
* Remove hack @included_messages - why is the file read twice (require should
  only read it once)?
* Uninstall in reverse direction unless we have hierarchic entries






== Low priority

Unit tests:
* Use TestEntry whereever useful (especially in entry_test)
* test Pathname.touch!
* test the TestHelper methods

Other:
* Make it possible to use coffle commands from the output directory (and
  subdirectories), using the actual (unescaped) filenames (allow completion)
* Whether a target is considered removed or replaced should not be depend on
  the existence of the backup, but instead on whether it was installed (keep a
  list)
  * then we can distinguish removed (no backup) from not installed on uninstall
  * either in a status file or in flag files
* Special files, like ssh authorized keys: define keys, then invoke keys in
  host blocks:
  {{{
  <% ssh_define_keys do %>
    ssh-dss AAAAB3N...DjB/A martin@magrathea
    ssh-dss AAAAB3N...Y2KjL martin@damogran
  <% end %>

  <% host "sedna" do %>
    <%= ssh_keys "martin@magrathea", "martin@damogran" %>
  <% end %>
  }}}
* colored messages (rainbow gem) (?) (no gem requirements!)
* distinguish preprocessor by file extension
  * additional file name escaping required
  * Pro: different pp possible
  * Con: collision possible
  * Allow unprocessed files.
    * special case of different preprocessor (pro/con see there)
    * symlink directly (target->source instead of ->output)?
      * Pro: changes to file possible
      * Con: 
* Conditionals: host classes, user names
* Specify individual files on the command line
  * Update automessage command to rebuild only this file
* Message if file is not installed on build
* command clean, which cleans source/.output etc.
  * only if nothing is installed, override with --force
  * print a warning that the symlinks are now broken
* facilitate ignoring autogenerated files for revision control
  * move all coffle directories (.output, .install) to coffle?
* coffle init
* coffle import
* allow help message/coffle init even in non-source-directory
* add .coffle_target/ to the target, so we can do coffle commands from there
* better solution for installing a removed or replaced target:
  * switches to drop the old back or the target
  * operation drop_backup
* similarly, allow uninstalling of removed or replaced target with a switch
* Handle error condition: backup directory is blocked by a file
* Handle error condition: when a directory was refused, all other entries in
  this directory must also be skipped (if the target directory for a file entry
  does not exist, we can probably assume that it was refused and skip its
  contents)
* tell the user what he did wrong and what to do on refuse
* allow "file should not exist" option (like skipping)
* allow "symlink to ..." (like skipping)
* Should we remove directory entries and just (try to) create the containing
  directory for file entries?
  * simplifies backup, validity rules etc.
  * means we cannot have empty directores
  * makes it more difficult to properly skip files whose path is blocked by
    another directory
* The operations should return a result object, with
  * a message
  * a performed flag
  * a success flag
* Test all test_helper methods, especially assert_tree_equal



