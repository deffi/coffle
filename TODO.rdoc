== Next


== High priority

* Should backup filenames really be unescaped?
  => advantage: simple to restore without coffle
  => disadvantage: no housekeeping files possible
     => not necessary with coffle files?
	    => unescape everwhere (except source)?
* Should there be a single .coffle directory in source?
  => probably yes, so we can freely add things later
  => where would things like host class definitions go? need further structure?
  => how are coffle source directories marked?
* Need a directory specification version, so we can add migrations
  => don't resort to "no spec => version 0" so we can recognize a missing spec
* Allow uninstalling entries which are no longer present




== Low priority

Unit tests:
* Use TestEntry whereever useful (especially in entry_test)
* test Pathname.touch!
* test the TestHelper methods
* In full_test, also compare file contents

Other:
* Remove hack @included_messages - why is the file read twice (require should
  only read it once)?
* Make it possible to use coffle commands from the output directory (and
  subdirectories), using the actual (unescaped) filenames (allow completion)
* Whether a target is considered removed or replaced should not be depend on
  the existence of the backup, but instead on whether it was installed (keep a
  list)
  * then we can distinguish removed (no backup) from not installed on uninstall
  * either in a status file or in flag files
* Special files, like ssh authorized keys: define keys, then invoke keys in
  host blocks:
  {{{
  <% ssh_define_keys do %>
    ssh-dss AAAAB3N...DjB/A martin@magrathea
    ssh-dss AAAAB3N...Y2KjL martin@damogran
  <% end %>

  <% host "sedna" do %>
    <%= ssh_keys "martin@magrathea", "martin@damogran" %>
  <% end %>
  }}}
* colored messages (rainbow gem) (?) (no gem requirements!)
* distinguish preprocessor by file extension
  * additional file name escaping required
  * Pro: different pp possible
  * Con: collision possible
  * Allow unprocessed files.
    * special case of different preprocessor (pro/con see there)
    * symlink directly (target->source instead of ->output)?
      * Pro: changes to file possible
      * Con: 
* Conditionals: host classes, user names
* Specify individual files on the command line
  * Update automessage command to rebuild only this file
* Message if file is not installed on build
* command clean, which cleans source/.output etc.
  * only if nothing is installed, override with --force
  * print a warning that the symlinks are now broken
* facilitate ignoring autogenerated files for revision control
  * move all coffle directories (.output, .install) to coffle?
* coffle init
* coffle import
* allow help message/coffle init even in non-source-directory
* add .coffle_target/ to the target, so we can do coffle commands from there
* better solution for installing a removed or replaced target:
  * switches to drop the old back or the target
  * operation drop_backup
* similarly, allow uninstalling of removed or replaced target with a switch
* Handle error condition: backup directory is blocked by a file
* Handle error condition: when a directory was refused, all other entries in
  this directory must also be skipped (if the target directory for a file entry
  does not exist, we can probably assume that it was refused and skip its
  contents)
* tell the user what he did wrong and what to do on refuse
* allow "file should not exist" option (like skipping)
* allow "symlink to ..." (like skipping)
* Should we remove directory entries and just (try to) create the containing
  directory for file entries?
  * simplifies backup, validity rules etc.
  * means we cannot have empty directores
  * makes it more difficult to properly skip files whose path is blocked by
    another directory
* The operations should return a result object, with
  * a message
  * a performed flag
  * a success flag
* Test all test_helper methods, especially assert_tree_equal
* Uninstalling directories:
  * With hierarchical entries structure
  * Currently, directories are removed if empty after uninstall, and uninstall
    is done in reverse order so the children are uninstalled first
  * Directories that were not created by coffle should not be removed
* The preconditions in the specific entries should be checked in the entries,
  or better yet (?), the methods just called and throw an exception/return a
  result if they cannot do that
* clean operations:
  * remove org/output, like skipping every entry
  * uninstall and remove org/output for entries no longer present
* On directory names:
  * the names output/org are bad
  * install and build are already used for the operations
  * The current interpretation is "process source to output (from where it is
	installed) and copy to org". Better: "process source to (a) and copy to
	(b) (from where it is installed)" - better outdated checks. (a) should
	probably be called "output".
* "Built" should include skipped and (successfully built) (need a name for
  this, or that)
* Autodetect entries which are no longer present (compare source/org)

