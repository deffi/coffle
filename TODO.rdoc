== Next

== High priority

* Cannot be distinguished: single file backup in directory, or directory backup
  with file?
  => maybe we cannot have directory entries?
  => would be bad, because we could not have empty directories
  => also, would not help, because we still may have a directory where we want
     to install a file entry
* Uninstall (restore backup)
  * What about directories with non-coffle files?
* skipping files
  * do we need to distinguish "none" and "don't touch"?
    => for now, "act as if it never happened" should be enough
  * how to mark a file as skipped?
	=> status file - yaml may be undesirable if gems cannot be installed
  * skipped means "not under coffle control on this machine", "act is if it did
    not exist"
  * skipped files are not installed
  * if already installed, uninstall
* "full" test for backups
* Should backup filenames be unescaped?
* Should there be a single .coffle directory in source?
  => probably yes, so we can freely add things later
* Need a directory specification version, so we can add migrations
  => don't resort to "no spec => version 0" so we can recognize a missing spec


== Documentation

* Not copying directly to target: because it is unclear whether the file was
  installed by coffle
* not .build/.install: because the install operation is something else
* no unescaped names in processing directories: so we can use dotfiles for bookkeeping


=== Backups ===

Goals:
* install (even with --overwrite) followed by uninstall => same as before

Conclusions:
* The only reason where we could possibly use multiple backups is to handle the
  case where the user replaced an installed entry, and we don't want to allow
  that. Therefore, a single backup is sufficient.
* If on "install" the backup is present and the target is "none" or "other", we
  may not keep the backup because after "uninstall", we would have restored an
  old backup. We also do not want to silently drop the backup after the user
  deletes the coffle link. Thus, we have to refuse.

Install
=======
target    |backup  ||condition          |backup action |target action |comments
----------+--------++-------------------+--------------+--------------+-------------------
installed |*       ||-                  |-             |-             |already current
----------+--------++-------------------+--------------+--------------+-------------------
none      |none    ||-                  |-             |install       |regular install
other     |none    ||--overwrite        |make          |install       |overwriting install
----------+--------++-------------------+--------------+--------------+-------------------
none      |present ||refuse                                           |target was removed
other     |present ||refuse                                           |target was replaced


Uninstall
=========
target    |backup  ||target action |backup action |comments
----------+--------++--------------+--------------+-------------------------------------
installed |present ||restore       |remove        |restore original file
installed |none    ||remove        |-             |restore (file was not present before)
----------+--------++--------------+--------------+-------------------------------------
none      |none    ||-             |-             |not installed (or: removed and not present before)
other     |none    ||-             |-             |not installed (or: replaced and not present before)
----------+--------++--------------+--------------+-------------------------------------
none      |present ||refuse                       |target was removed
other     |present ||refuse                       |target was replaced



== Low priority

* Special files, like ssh authorized keys: define keys, then invoke keys in
  host blocks:
  {{{
  <% ssh_define_keys do %>
    ssh-dss AAAAB3N...DjB/A martin@magrathea
    ssh-dss AAAAB3N...Y2KjL martin@damogran
  <% end %>

  <% host "sedna" do %>
    <%= ssh_keys "martin@magrathea", "martin@damogran" %>
  <% end %>
  }}}
* colored messages (rainbow gem) (?) (no gem requirements!)
* distinguish preprocessor by file extension
  * additional file name escaping required
  * Pro: different pp possible
  * Con: collision possible
  * Allow unprocessed files.
    * special case of different preprocessor (pro/con see there)
    * symlink directly (target->source instead of ->build)?
      * Pro: changes to file possible
      * Con: 
* Conditionals: host classes, user names
* Specify individual files on the command line
  * Update automessage command to rebuild only this file
* Message if file is not installed on build
* command clean, which cleans source/.build etc.
  * only if nothing is installed, override with --force
  * print a warning that the symlinks are now broken
* facilitate ignoring autogenerated files for revision control
  * move all coffle directories (.build, .install) to coffle?
* coffle init
* coffle import
* allow help message/coffle init even in non-source-directory
* add .coffle_target/ to the target, so we can do coffle commands from there
* better solution for installing a removed or replaced target:
  * switches to drop the old back or the target
  * operation drop_backup
* similarly, allow uninstalling of removed or replaced target with a switch
* implementation: there should be a DirectoryClass and a FileClass
* Handle error condition: backup directory is blocked by a file
* Handle error condition: when a directory was refused, all other entries in
  this directory must also be skipped (if the directory does not exist, we can
  probably assume that it was refused and skip its contents)
* tell the user what he did wrong and what to do on refuse


