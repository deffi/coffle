== Next

* Unit tests for uninstall

* Uninstall (restore backup)
  => must remove backup, or it will count as removed
* Uninstalling directories:
  * Need hierarchical entries structure?
  * Simple approach: remove directory if empty after children uninstalled
  * Better: remove directory if empty and was created by coffle?

The operations should return a result object, with
* a message
* a performed flag
* a success flag


== High priority

* Whether a target was removed or replaced should not be depend on the
  existence of the backup, but instead on whether it was installed (keep a
  list)
  * then we can distinguish removed (no backup) from not installed on uninstall
* The preconditions in the specific entries should be checked in the entries,
  or better yet (?), the methods just called and throw an exception/return a
  result if they cannot do that
* install! et al should be private
* skipping files
  * how to mark a file as skipped?
	=> status file - yaml may be undesirable if gems cannot be installed
* "full" test for backups
* "full" test: install into symlink directory
* Should backup filenames really be unescaped?
* Should there be a single .coffle directory in source?
  => probably yes, so we can freely add things later
  => where would things like host class definitions go? need further structure?
  => how are coffle source directories marked?
* Need a directory specification version, so we can add migrations
  => don't resort to "no spec => version 0" so we can recognize a missing spec
* What happens if a entry is no longer present? how to detect?
  => should be restored
  => ?
* Remove hack @included_messages - why is the file read twice (require should
  only read it once)?


== Documentation

* Not copying directly to target: because it is unclear whether the file was
  installed by coffle
* not .build/.install: because the install operation is something else
* no unescaped names in processing directories: so we can use dotfiles for bookkeeping

On directories:
* If the target of a directory entry already exists, we use it and keep its contents.
** coffle directores are the same as other directories
** we want to keep, for example, .ssh/identity when installing .ssh/config
* We accept a symlink to a directory as existing target directory

For now, we don't allow overwriting a file with a directory or vice versa.
We never make a backup of a directory (cannot be overwritten by a file
(refused) nor a directory (exists)).

Notes on backups of directories (in case we want to make them one day):
* Can we/do we have to distinguish a file backup in a directory from a
  directory backup?
* What about uninstalling directories that contain non-coffle entries?


On skipping:
* skipped means: not under coffle control
* act as if the entry didn't exist
* file ist not installed
* if it is already installed, uninstall it

On uninstalling:
* the backup must be removed, or the entry will be treated as removed

=== Backups ===

Goals:
* install (even with --overwrite) followed by uninstall => same as before

Conclusions:
* The only reason to use multiple backups would be to allow the user to replace
  the the installed entries. However, this is probably neither easy nor simple.
  Therefore, we only use a single backup.
* If on "install" the backup is present and the target is "none" or "other", we
  may not keep the backup because after "uninstall", we would have restored an
  old backup. We also do not want to silently drop the backup after the user
  deletes the coffle link. Thus, we have to refuse.



Install
=======
type      |target    |backup  |overwrite ||backup action |target action |comments
----------+----------+--------+----------++--------------+--------------+-------------------
*         |installed |*       |*         ||-             |-             |already current
----------+----------+--------+----------++--------------+--------------+-------------------
*         |none      |present |*         ||            refuse           |target was removed
*         |wrong     |present |*         ||            refuse           |target was replaced
----------+----------+--------+----------++--------------+--------------+-------------------
*         |none      |none    |*         ||-             |install       |regular install
----------+----------+--------+----------++--------------+--------------+-------------------
file      |dir       |none    |*         ||            refuse           |file blocked by dir
dir       |file      |none    |*         ||            refuse           |dir blocked by file
file      |file      |none    |false     ||-             |-             |not overwriting
file      |file      |none    |true      ||make          |install       |overwriting install

Note:
* For directory entries, there is no overwriting install, since an existing
  directory will be treated as target=installed
* removed and replaced is only detected when there is a backup, which is never
  the case for directory entries.





Uninstall
=========
target    |backup  ||target action |backup action |comments
----------+--------++--------------+--------------+-------------------------------------
installed |present ||restore       |remove        |regular uninstall with restore
installed |none    ||remove        |-             |regular uninstall without restore
----------+--------++--------------+--------------+-------------------------------------
none      |present ||            refuse           |target was removed
other     |present ||            refuse           |target was replaced
----------+--------++--------------+--------------+-------------------------------------
none      |none    ||-             |-             |not installed (or: removed and not present before)
other     |none    ||-             |-             |not installed (or: replaced and not present before)



== Low priority

Unit tests:
* Use TestEntry whereever useful (especially in entry_test)
* test Pathname.touch!
* test the TestHelper methods

Other:
* Special files, like ssh authorized keys: define keys, then invoke keys in
  host blocks:
  {{{
  <% ssh_define_keys do %>
    ssh-dss AAAAB3N...DjB/A martin@magrathea
    ssh-dss AAAAB3N...Y2KjL martin@damogran
  <% end %>

  <% host "sedna" do %>
    <%= ssh_keys "martin@magrathea", "martin@damogran" %>
  <% end %>
  }}}
* colored messages (rainbow gem) (?) (no gem requirements!)
* distinguish preprocessor by file extension
  * additional file name escaping required
  * Pro: different pp possible
  * Con: collision possible
  * Allow unprocessed files.
    * special case of different preprocessor (pro/con see there)
    * symlink directly (target->source instead of ->output)?
      * Pro: changes to file possible
      * Con: 
* Conditionals: host classes, user names
* Specify individual files on the command line
  * Update automessage command to rebuild only this file
* Message if file is not installed on build
* command clean, which cleans source/.output etc.
  * only if nothing is installed, override with --force
  * print a warning that the symlinks are now broken
* facilitate ignoring autogenerated files for revision control
  * move all coffle directories (.output, .install) to coffle?
* coffle init
* coffle import
* allow help message/coffle init even in non-source-directory
* add .coffle_target/ to the target, so we can do coffle commands from there
* better solution for installing a removed or replaced target:
  * switches to drop the old back or the target
  * operation drop_backup
* similarly, allow uninstalling of removed or replaced target with a switch
* Handle error condition: backup directory is blocked by a file
* Handle error condition: when a directory was refused, all other entries in
  this directory must also be skipped (if the target directory for a file entry
  does not exist, we can probably assume that it was refused and skip its
  contents)
* tell the user what he did wrong and what to do on refuse
* allow "file should not exist" option (like skipping)
* allow "symlink to ..." (like skipping)
* Should we remove directory entries and just (try to) create the containing
  directory for file entries?
  * simplifies backup, validity rules etc.
  * means we cannot have empty directores
  * makes it more difficult to properly skip files whose path is blocked by
    another directory


