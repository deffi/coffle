== Next

* coffle init

* on startup, make sure our version is current (and unit test)




== High priority

* Allow uninstalling entries which are no longer present
* Use .coffle_target link in target
  * allows moving a source without breaking the link by copying, changing the
    link, and deleting the old copy
  * simplifies link targets
  * useful for access from target directory (future extension)




== Low priority

Operations:
* init
* remove org/output (if installed: refuse, or uninstall)
  * should uninstall do this?
* uninstall all entries no longer present
* diff (show difference between output and org)
* import (existierende Konfigurationsdatei in source kopieren, escapen)

Unit tests:
* Use TestEntry whereever useful (especially in entry_test)
* test Pathname.touch!
* test the TestHelper methods
* In full_test, also compare file contents
* Test all test_helper methods, especially assert_tree_equal

Build actions:
* regular build (done)
* skip (ignore) (done)
* remove (file should not exist) (needs status file entry)
* symlink (does a symlink have an own timestamp?)
* When adding more, we probably want
  * to always use the timestamp from the status file
  * a build_result value instead of flags

Source files:
* distinguish preprocessor by file extension
  * additional file name escaping required
  * Pro: different pp possible
  * Con: collision possible
  * Allow unprocessed files?
    * special case of different preprocessor (pro/con see there)
    * symlink directly (target->source instead of ->output)?
      * Pro: changes to file possible
      * Con: 
* Whether a target is considered removed or replaced should not be depend on
  the existence of the backup, but instead on whether it was installed (keep a
  list)
  * then we can distinguish removed (no backup) from not installed on uninstall
  * either in a status file or in flag files

Template processing:
* Special files, like ssh authorized keys: define keys, then invoke keys in
  host blocks:
  {{{
  <% ssh_define_keys do %>
    ssh-dss AAAAB3N...DjB/A martin@magrathea
    ssh-dss AAAAB3N...Y2KjL martin@damogran
  <% end %>

  <% host "sedna" do %>
    <%= ssh_keys "martin@magrathea", "martin@damogran" %>
  <% end %>
  }}}
* Conditionals: host classes, user names

UI:
* Specify individual files on the command line
  * Update automessage command to rebuild only this file
* Allow specifying directories (operate on all contents?)
* Message on build if file is not installed
* colored messages
  * rainbow gem can be used
    * allow operation without gem (rubygems may not be available)
* allow help message/coffle init even in non-source-directory
* better solution for installing a removed or replaced target:
  * switches to drop the old back or the target
  * operation drop_backup
* similarly, allow uninstalling of removed or replaced target with a switch
* tell the user what he did wrong and what to do on refuse

Target:
* Make it possible to use coffle commands from the target directory (and
  subdirectories), using the actual (unescaped) filenames (allow completion)
  * add .coffle_target/ to the target

Error conditions:
* backup directory is blocked by a file
* when a directory was refused, all other entries in this directory must also
  be skipped (if the target directory for a file entry does not exist, we can
  probably assume that it was refused and skip its contents)

Implementation:
* Remove hack @included_messages - why is the file read twice (require should
  only read it once)?
* The operations should return a result object, with
  * a message
  * a performed flag
  * a success flag
* The preconditions in the specific entries should be checked in the entries,
  or better yet (?), the methods just called and throw an exception/return a
  result if they cannot do that

Naming:
* "Built" should include skipped and (successfully built) (need a name for
  this, or that)
* On directory names:
  * the names output/org are bad
  * install and build are already used for the operations
  * The current interpretation is "process source to output (from where it is
	installed) and copy to org". Better: "process source to (a) and copy to
	(b) (from where it is installed)" - better outdated checks. (a) should
	probably be called "output" (or "build" if we can rename the operation).

Entries:
* Directory entries:
  * no directory entries?
    * (try to) create the containing directory for file entries
    * pro: simplifies stuff
	* con: empty directories not possible
	* con: makes it more difficult to properly skip files whose path is blocked
	  by another directory
  * hierarchical entries structure?
    * simplifies uninstalling directories
    * Currently, directories are removed if empty after uninstall, and uninstall
      is done in reverse order so the children are uninstalled first
    * Directories that were not created by coffle should not be removed
* Autodetect entries which are no longer present (compare source/org)

